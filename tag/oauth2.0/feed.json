{
    "version": "https://jsonfeed.org/version/1",
    "title": "The course of true love never did run smooth. • All posts by \"oauth2.0\" tag",
    "description": "不知道写啥",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%9D%82%E7%83%A9/OAuth2-0%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F/",
            "url": "http://example.com/%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%9D%82%E7%83%A9/OAuth2-0%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F/",
            "title": "OAuth2.0的四种授权模式",
            "date_published": "2020-04-08T02:40:53.000Z",
            "content_html": "<h1 id=\"oauth20-为何物\"><a class=\"markdownIt-Anchor\" href=\"#oauth20-为何物\">#</a> <strong>OAuth2.0 为何物</strong></h1>\n<p><code>OAuth</code>  简单理解就是一种授权机制，它是在客户端和资源所有者之间的授权层，用来分离两种不同的角色。在资源所有者同意并向客户端颁发令牌后，客户端携带令牌可以访问资源所有者的资源。<br>\n <code>OAuth2.0</code>  是 <code>OAuth</code>  协议的一个版本，有 <code>2.0</code>  版本那就有 <code>1.0</code>  版本，有意思的是 <code>OAuth2.0</code>  却不向下兼容 <code>OAuth1.0</code>  ，相当于废弃了 <code>1.0</code>  版本。</p>\n<p><strong>举个小栗子解释一下什么是 OAuth 授权？</strong><br>\n在家肝文章饿了定了一个外卖，外卖小哥 30 秒火速到达了我家楼下，奈何有门禁进不来，可以输入密码进入，但出于安全的考虑我并不想告诉他密码。<br>\n此时外卖小哥看到门禁有一个高级按钮 “ <code>一键获取授权</code> ”，只要我这边同意，他会获取到一个有效期 2 小时的令牌（ <code>token</code> ）正常出入。</p>\n<p>令牌（ <code>token</code> ）和  <code>密码</code>  的作用虽然相似都可以进入系统，但还有点不同。 <code>token</code>  拥有权限范围，有时效性的，到期自动失效，而且无效修改</p>\n<p><code>OAuth2.0</code>  的授权简单理解其实就是获取令牌（ <code>token</code> ）的过程， <code>OAuth</code>  协议定义了四种获得令牌的授权方式（ <code>authorization grant</code>  ）如下：</p>\n<ul>\n<li>隐式授权模式（Implicit Grant）</li>\n<li>授权码授权模式（Authorization code Grant）</li>\n<li>密码模式（Resource Owner Password Credentials Grant）</li>\n<li>客户端凭证模式（Client Credentials Grant）</li>\n</ul>\n<p>但值得注意的是，不管我们使用哪一种授权方式，在三方应用申请令牌之前，都必须在系统中去申请身份唯一标识：客户端 ID（ <code>client ID</code> ）和 客户端密钥（ <code>client secret</code> ）。这样做可以保证  <code>token</code>  不被恶意使用。<br>\n下面我们会分析每种授权方式的原理，在进入正题前，先了解  <code>OAuth2.0</code>  授权过程中几个重要的参数：</p>\n<ul>\n<li><code>response_type</code> ：code 表示要求返回授权码，token 表示直接返回令牌</li>\n<li><code>client_id</code> ：客户端身份标识</li>\n<li><code>client_secret</code> ：客户端密钥</li>\n<li><code>redirect_uri</code> ：重定向地址</li>\n<li><code>scope</code> ：表示授权的范围， <code>read</code>  只读权限， <code>all</code>  读写权限</li>\n<li><code>grant_type</code> ：表示授权的方式， <code>AUTHORIZATION_CODE</code> （授权码）、 <code>password</code> （密码）、 <code>client_credentials</code> （凭证式）、 <code>refresh_token</code>  更新令牌</li>\n<li><code>state</code> ：应用程序传递的一个随机数，用来防止 <code>CSRF</code>  攻击。</li>\n</ul>\n<hr>\n<h1 id=\"1隐式授权模式implicit-grant\"><a class=\"markdownIt-Anchor\" href=\"#1隐式授权模式implicit-grant\">#</a> 1. 隐式授权模式（Implicit Grant）</h1>\n<p><img data-src=\"1.png\" alt=\"\"></p>\n<ul>\n<li>第一步：用户访问页面时，重定向到认证服务器。</li>\n<li>第二步：认证服务器给用户一个认证页面，等待用户授权。</li>\n<li>第三步：用户授权，认证服务器想应用页面返回 Token</li>\n<li>第四步：验证 Token，访问真正的资源页面</li>\n</ul>\n<p><img data-src=\"2.png\" alt=\"\"></p>\n<h1 id=\"2授权码授权模式authorization-code-grant\"><a class=\"markdownIt-Anchor\" href=\"#2授权码授权模式authorization-code-grant\">#</a> 2. 授权码授权模式（Authorization code Grant）</h1>\n<p><img data-src=\"3.png\" alt=\"\"></p>\n<ul>\n<li>第一步：用户访问页面</li>\n<li>第二步：访问的页面将请求重定向到认证服务器</li>\n<li>第三步：认证服务器向用户展示授权页面，等待用户授权</li>\n<li>第四步：用户授权，认证服务器生成一个 code 和带上 client_id 发送给应用服务器，然后，应用服务器拿到 code，并用 client_id 去后台查询对应的 client_secret</li>\n<li>第五步：将 code、client_id、client_secret 传给认证服务器换取 access_token 和 refresh_token</li>\n<li>第六步：将 access_token 和 refresh_token 传给应用服务器</li>\n<li>第七步：验证 token，访问真正的资源页面</li>\n</ul>\n<p><img data-src=\"4.png\" alt=\"\"></p>\n<h1 id=\"3密码模式resource-owner-password-credentials-grant\"><a class=\"markdownIt-Anchor\" href=\"#3密码模式resource-owner-password-credentials-grant\">#</a> 3. 密码模式（Resource Owner Password Credentials Grant）</h1>\n<p><img data-src=\"5.png\" alt=\"\"></p>\n<ul>\n<li>第一步：用户访问用页面时，输入第三方认证所需要的信息 (QQ / 微信账号密码)</li>\n<li>第二步：应用页面那种这个信息去认证服务器授权</li>\n<li>第三步：认证服务器授权通过，拿到 token，访问真正的资源页面</li>\n</ul>\n<p><code>优点</code> ：不需要多次请求转发，额外开销，同时可以获取更多的用户信息。(都拿到账号密码了)</p>\n<p><code>缺点</code> ：局限性，认证服务器和应用方必须有超高的信赖。(比如亲兄弟？)</p>\n<p><code>应用场景</code> ：自家公司搭建的认证服务器</p>\n<h1 id=\"4客户端凭证模式client-credentials-grant\"><a class=\"markdownIt-Anchor\" href=\"#4客户端凭证模式client-credentials-grant\">#</a> 4. 客户端凭证模式（Client Credentials Grant）</h1>\n<p><img data-src=\"6.png\" alt=\"\"></p>\n<ul>\n<li>第一步：用户访问应用客户端</li>\n<li>第二步：通过客户端定义的验证方法，拿到 token，无需授权</li>\n<li>第三步：访问资源服务器 A</li>\n<li>第四步：拿到一次 token 就可以畅通无阻的访问其他的资源页面。</li>\n</ul>\n<p><strong>这是一种最简单的模式，只要 client 请求，我们就将 AccessToken 发送给它。这种模式是最方便但最不安全的模式。因此这就要求我们对 client 完全的信任，而 client 本身也是安全的。</strong></p>\n<p><strong>因此这种模式一般用来提供给我们完全信任的服务器端服务。在这个过程中不需要用户的参与。</strong></p>\n",
            "tags": [
                "OAuth2.0"
            ]
        }
    ]
}