{
    "version": "https://jsonfeed.org/version/1",
    "title": "The course of true love never did run smooth. • All posts by \"vue生命周期\" tag",
    "description": "不知道写啥",
    "home_page_url": "http://tuyustar.cn",
    "items": [
        {
            "id": "http://tuyustar.cn/Vue/Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E4%BB%8E%E6%91%87%E7%AF%AE%E5%88%B0%E5%9D%9F%E5%A2%93/",
            "url": "http://tuyustar.cn/Vue/Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E4%BB%8E%E6%91%87%E7%AF%AE%E5%88%B0%E5%9D%9F%E5%A2%93/",
            "title": "生命周期(从摇篮到坟墓)",
            "date_published": "2020-08-08T13:25:02.000Z",
            "content_html": "<h1 id=\"vue生命周期\"><a class=\"markdownIt-Anchor\" href=\"#vue生命周期\">#</a> Vue–生命周期</h1>\n<img data-src=\"1.png\"/>\n<h3 id=\"生命周期是什么\"><a class=\"markdownIt-Anchor\" href=\"#生命周期是什么\">#</a> 生命周期是什么</h3>\n<blockquote>\n<p>生命周期 <code>（Life Cycle）</code> 的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为 “从摇篮到坟墓” <code>（Cradle-to-Grave）</code> 的整个过程</p>\n<p>在 <code>Vue</code>  中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载 Dom→渲染、更新→渲染、销毁等一系列过程</p>\n<p>我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作</p>\n</blockquote>\n<h3 id=\"生命周期有哪些\"><a class=\"markdownIt-Anchor\" href=\"#生命周期有哪些\">#</a> 生命周期有哪些</h3>\n<p>先搂一眼官方文档的图片</p>\n<center><img data-src=\"3.png\"  /></center>\n<ul>\n<li>Vue 生命周期总共可以分为 8 个阶段：创建前后，载入前后，更新前后，销毁前销毁后</li>\n</ul>\n<h3 id=\"1-在beforecreate和created钩子函数之间的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#1-在beforecreate和created钩子函数之间的生命周期\">#</a> 1. <strong>在 beforeCreate 和 created 钩子函数之间的生命周期</strong></h3>\n<ul>\n<li>\n<p>在这个生命周期之间，进行<strong>初始化事件，进行数据的观测</strong>，在 <code>created</code>  的时候数据已经和 <code>data</code> <strong> 属性进行绑定</strong>（放在 data 中的属性当值发生改变的同时，视图也会改变）。</p>\n</li>\n<li>\n<p><code>注意：此时还是没有el选项</code></p>\n</li>\n</ul>\n<h3 id=\"2-created钩子函数和beforemount间的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#2-created钩子函数和beforemount间的生命周期\">#</a> <strong>2. created 钩子函数和 beforeMount 间的生命周期</strong></h3>\n<center><img data-src=\"4.png\"  /></center>\n<p>在这一阶段发生的故事还是比较多的。</p>\n<ul>\n<li>\n<p>首先判断是否存在 <code>el</code>  选项，若不存在则停止编译，直到调用 <code>vm.$mount(el)</code>  才会继续编译</p>\n</li>\n<li>\n<p>是否有模板，有则将模板转化为 <code>render</code>  函数，通过 <code>render</code>  函数去渲染创建 <code>Dom</code>  树，无则编译 <code>el</code>  对象外层 <code>HTML</code>  作为模板</p>\n</li>\n<li>\n<p>优先级： <code>render</code>  &gt;  <code>template</code>  &gt;  <code>outerHTML</code></p>\n</li>\n</ul>\n<h3 id=\"3-beforemount和mounted-钩子函数间的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#3-beforemount和mounted-钩子函数间的生命周期\">#</a> <strong>3. beforeMount 和 mounted 钩子函数间的生命周期</strong></h3>\n<center><img data-src=\"5.png\"  /></center>\n<ul>\n<li>此阶段 <code>vm.el</code>  完成挂载， <code>vm.$el</code>  生成的 <code>DOM</code>  替换了 <code>el</code>  选项所对应的 <code>DOM</code></li>\n</ul>\n<h3 id=\"4-mounted\"><a class=\"markdownIt-Anchor\" href=\"#4-mounted\">#</a> <strong>4. mounted</strong></h3>\n<ul>\n<li><code>vm.el</code>  已完成 <code>DOM</code>  的挂载与渲染，此刻打印 <code>vm.$el</code> ，发现之前的挂载点及内容已被替换成新的 <code>DOM</code></li>\n</ul>\n<h3 id=\"5-beforeupdate钩子函数和updated钩子函数间的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#5-beforeupdate钩子函数和updated钩子函数间的生命周期\">#</a> <strong>5. beforeUpdate 钩子函数和 updated 钩子函数间的生命周期</strong></h3>\n<center><img data-src=\"6.png\"  /></center>\n<ul>\n<li>当 vue 发现 data 中的数据发生了改变，会<strong>触发对应组件的重新渲染</strong>，先后调用 <code>beforeUpdate</code>  和 <code>updated</code>  钩子函数</li>\n</ul>\n<h3 id=\"6beforedestroy\"><a class=\"markdownIt-Anchor\" href=\"#6beforedestroy\">#</a> 6.<strong>beforeDestroy</strong></h3>\n<ul>\n<li><code>0beforeDestroy</code>  钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。</li>\n</ul>\n<h3 id=\"7destroyed\"><a class=\"markdownIt-Anchor\" href=\"#7destroyed\">#</a> 7.<strong>destroyed</strong></h3>\n<ul>\n<li><code>destroyed</code>  钩子函数在 <code>Vue </code> 实例销毁后调用。调用后， <code>Vue </code> 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁，并不能清除 <code>Dom </code> ，仅仅销毁实例</li>\n</ul>\n<h3 id=\"数据请求在created和mouted的区别\"><a class=\"markdownIt-Anchor\" href=\"#数据请求在created和mouted的区别\">#</a> 数据请求在 created 和 mouted 的区别</h3>\n<ul>\n<li>\n<p><code>created</code>  是在组件实例一旦创建完成的时候立刻调用，这时候页面 <code>dom</code>  节点并未生成</p>\n</li>\n<li>\n<p><code>mounted</code>  是在页面 <code>dom</code>  节点渲染完毕之后就立刻执行的</p>\n</li>\n<li>\n<p>触发时机上 <code>created</code>  是比 <code>mounted</code>  要更早的</p>\n</li>\n<li>\n<p>两者相同点：都能拿到实例对象的属性和方法</p>\n</li>\n<li>\n<p>讨论这个问题本质就是触发的时机，放在 <code>mounted</code>  请求有可能导致页面闪动（页面 <code>dom</code>  结构已经生成），但如果在页面加载前完成则不会出现此情况</p>\n</li>\n</ul>\n",
            "tags": [
                "vue生命周期"
            ]
        }
    ]
}